{"version":3,"file":"wdf.js","sources":["webpack:///webpack/bootstrap 979e50a2528cb427238c","webpack:///./index.js","webpack:///./wdf/types.js","webpack:///./wdf/utils.js","webpack:///./wdf/DataFrame.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 979e50a2528cb427238c\n **/","module.exports = {\n  types: require(\"./wdf/types\"),\n  utils: require(\"./wdf/utils\"),\n  DataFrame: require(\"./wdf/DataFrame\"),\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","//  misc utilities. Initialize it like:\n//  ```\n//    var u$ = require(\"./utils\");\n//  ```\nvar u$ = require(\"./utils\");\n// ## private stuff\n\n// order functions take two arguments (let's say `a` and `b`)\n// and compare them.\n//\n// Returns:\n//   * `-1` if `a` less then `b`\n//   * `1` if `a` greater then `b`\n//   * `null` if `a` equals `b`  but you want next\n//     order function in chain have it's say\n//   * `0` if `a` equals `b` period.\n//\n// here is generic order function ->\nfunction generic_order(a,b){\n  return a === b ? null : a < b ? -1 : 1 ;\n}\n\nfunction Type(name, props) {\n  this.name = name ;\n  this.is = props.is ;\n  this.from_string = props.from_string ;\n  this.notnull_to_string = props.notnull_to_string || u$.ensureString ;\n  this.to_string = props.to_string || function (v){\n        return u$.isNullish(v) ? \"\" : this.notnull_to_string(v) ;\n      };\n  this.order = props.order || generic_order;\n  this.compare = t$.orderNullsFirst(this.order);\n  t$.types = t$.types || [];\n  t$.types.push(this);\n  t$[name] = this;\n}\n// ## PUBLIC FUNCTIONS\nvar t$ = Type;\nmodule.exports = t$ ;\n\n\n// ** orderChain(array) **\n//\n// Create chain of order functions.\nt$.orderChain = function(){\n  var funcs = u$.extractArray(arguments);\n  return function(a,b){\n    var rc = 0;\n    for (var i = 0; i < funcs.length; i++) {\n      var res = funcs[i](a,b);\n      if( res !== null ){\n        rc = res;\n        break;\n      }\n    }\n    return rc;\n  };\n};\n// **orderPredicateFirst(is)**\n//\n// Turn predicate function(returning `true` or `false`) into\n// order function. Order function place `true` first.\nt$.orderPredicateFirst = function (is) {\n  return function(a, b) {\n    return is(a) ? (is(b) ? 0 : -1) : (is(b) ? 1 : null);\n  };\n};\n\n// Assume we have `indexArray` and `valueArray`. We also have `valueOrder(a,b)`\n// function that capable of comparing elements of `valueArray`. `indexArray`\n// contains integers pointing to `valueArray`. That set up allow messing with\n// order or composition of `indexArray` leave order of `valueArray` unchanged.\n\n// **indexOrder (valueOrder, valueArray)**\n//\n// creates index order function for given `valueOrder(a,b)`\n\nt$.indexOrder = function (valueOrder, valueArray) {\n  return function(a, b) {\n    return valueOrder(valueArray[a],valueArray[b]);\n  };\n};\n\n// ** extractValuesByIndex (indexArray, valueArray)**\n//\n// extract values out of `valueArray` usinf `indexArray`\nt$.extractValuesByIndex = function (indexArray, valueArray) {\n  return indexArray.map(function(idx){return valueArray[idx];});\n};\n\n// ** createIndex(valueArray) **\n//\n// returns index array matching `valueArray`\nt$.createIndex = function (valueArray) {\n  return u$.range(valueArray.length);\n};\n// **orderInverse(f)**\n//\n// inverse order mandated by `f(a,b)`\nt$.orderInverse = function(f) {\n  return function(a, b) {\n    return f(b, a);\n  };\n};\n//** orderNullsFirst(orderFuncArray) **\n//\n// Create order function that sort `undefined` - first, `null` - second\n// and then according to order functions provided in argument.\nt$.orderNullsFirst = function(){\n  var funcs = u$.extractArray(arguments);\n  funcs.splice(0,0,t$.orderPredicateFirst(u$.isUndef));\n  funcs.splice(1,0,t$.orderPredicateFirst(u$.isNull));\n  return t$.orderChain(funcs);\n};\n// ** addTypes(typesMap) **\n//\n//    add types\nt$.addTypes=function(typesMap){\n  for(var typeName in typesMap){\n    if( typesMap.hasOwnProperty(typeName) ){\n      new Type(typeName,typesMap[typeName]);\n    }\n  }\n};\n\nvar NANs = [\"\",\"NaN\",\"null\"];\n\nvar BOOLEAN_STRINGS = (function(a){\n  return a.concat(a.map(function(s){return s[0];}));\n})([\"no\",\"yes\",\"false\",\"true\",\"0\",\"1\"]);\n\nt$.addTypes({\n// ** string ** type\n  string: {\n    is: function(v){\n      return u$.isString(v);\n    },\n    from_string: function(v){\n      return \"\" === v ? null : v ;\n    }\n  },\n// ** number ** type\n  number: {\n    is: function(v){\n      return u$.isNumber(v);\n    },\n    from_string: function(v){\n      return NANs.indexOf(v) > -1 ? NaN :  u$.numDefault(+v,undefined);\n    },\n    notnull_to_string: function(v){\n      return isNaN(v)? '' : v;\n    },\n  },\n// ** boolean ** type\n  boolean: {\n    is: function(v){\n      return u$.isBoolean(v);\n    },\n    from_string: function(v){\n      var idx = BOOLEAN_STRINGS.indexOf(v.toLowerCase());\n      return idx < 0 ? undefined : idx % 2 === 1 ;\n    },\n    order: function(a, b) {\n      return a ? (b ? null : 1) : (b ? -1 : null);\n    }\n  },\n// ** datetime ** type\n  datetime: {\n    is: function(v){\n      return u$.isDate(v);\n    },\n    from_string: u$.date_from_string,\n    notnull_to_string: u$.date_to_string_fn(\"YYYY_MM_DD_hh_mm_ss\"),\n    order: function(a, b) {\n      return generic_order( a.valueOf(), b.valueOf());\n    }\n  },\n// ** date ** type\n  date: {\n    is: function(v){\n      return u$.isDate(v);\n    },\n    from_string: u$.date_from_string,\n    notnull_to_string: u$.date_to_string_fn(\"YYYY_MM_DD\"),\n    order: function(a, b) {\n      return generic_order( a.valueOf(), b.valueOf());\n    }\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wdf/types.js\n ** module id = 1\n ** module chunks = 0\n **/","\n//  misc utilities. Initialize it like:\n//  ```\n//    var u$ = requre(\"wdf/utils\");\n//  ```\nvar u$ = module.exports = {} ;\n//\n// ## Detect Types\n\n\n// **isArray(o)**\n//\n// `true` if `o` is Array\nu$.isArray=function(o) {\n  return Object.prototype.toString.call(o) === '[object Array]';\n};\n\n// **isString(o)**\n//\n// `true` if `o` is String\nu$.isString=function(a) {\n  return typeof a === \"string\" || a instanceof String;\n};\n\n// **isNumber(o)**\n//\n// `true` if `o` is number\nu$.isNumber=function(a) {\n  return typeof a === \"number\" || a instanceof Number;\n};\n\n// **isInteger(o)**\n//\n// `true` if `o` is whole number\nu$.isInteger=function(a) {\n  return u$.isNumber(a) && a % 1 === 0;\n};\n\n// **isBoolean(o)**\n//\n// `true` if `o` is boolean\nu$.isBoolean=function(a) {\n  return typeof a === \"boolean\" || a instanceof Boolean;\n};\n\n// **isFunction(o)**\n//\n// `true` if `o` is function\nu$.isFunction=function(a) {\n  return typeof a === \"function\" || a instanceof Function;\n};\n\n// **isDate(o)**\n//\n// `true` if `o` is Date\nu$.isDate=function(a) {\n  return a instanceof Date;\n};\n\n// **isUndef(o)**\n//\n// `true` if `o` is undefined\nu$.isUndef=function(x) {\n  return x === undefined; //TODO: consider to use: typeof x === \"undefined\"\n};\n\n// **isNull(o)**\n//\n// `true` if `o` is null\nu$.isNull=function(x)  {\n  return x === null;\n};\n\n\n// **isNullish(o)**\n//\n// `true` if `o` is boolean\nu$.isNullish=function(a) {\n  return a === null || a === undefined;\n};\n\n\n// **isPrimitive(a)**\n//\n// returns `true` if `a` is build-in non composite type\nu$.isPrimitive=function(a) {\n  return u$.isString(a) || u$.isNumber(a) || u$.isBoolean(a) ||\n      u$.isFunction(a) || u$.isDate(a);\n};\n\n\n// **isObject(a)**\n//\n// returns `true` if `a` is not primitive, not empty, and not array\nu$.isObject=function(a) {\n  return !u$.isNullish(a) && !u$.isPrimitive(a) && !u$.isArray(a);\n};\n\n\n// **isArrayEmpty(array)**\n//\n// returns `true` if `array` is nullish or empty\nu$.isArrayEmpty=function(array){\n  return u$.isNullish(array) || (u$.isArray(array) && array.length === 0);\n};\n\n\n// **isStringEmpty(s)**\n//\n// returns `true` if `s` is nullish or empty string\nu$.isStringEmpty=function(s){\n  return u$.isNullish(s) || (u$.isString(s) && s.trim().length() === 0);\n};\n\n\n// **numDefault(v,default_v)**\n//\n// returns `default_v` if `v` is Nullish or NaN, otherwise returns `v`\nu$.numDefault=function(v,default_v){\n  if(u$.isNullish(v) || isNaN(v)){\n    return default_v;\n  }\n  return v;\n};\n\n\n\n// ## Function Utils\n\n//**brodcastCall(brodcastTo, funcName, args, vocal)**\n//\n// call method with `funcName` on each object from `brodcastTo`\n// array. `args` passed for each of these calls. `vocal` - optional\n// controls error throwing behavior, default or false be silent -\n// do not throw exceptions.\nu$.brodcastCall=function(brodcastTo, funcName, args, vocal){\n  vocal = vocal || false;\n  if(! u$.isArrayEmpty(brodcastTo) ){\n    brodcastTo.forEach(\n        function(castTo){\n          var f = castTo[funcName];\n          if( u$.isFunction(f) ){\n            f.apply(castTo,args);\n          }else if( vocal ){\n            throw u$.error({message: \"No such function\", funcName: funcName, obj: castTo });\n          }\n        }\n    );\n  }\n};\n\n\n//** new_Object(constructor, args) **\n//\n// Call `constructor` passing variable number of `args` as  array\n\nu$.new_Object = function(constructor, args) {\n  var new_obj = Object.create(constructor.prototype);\n  var ctor_ret = constructor.apply(new_obj, args);\n  return ctor_ret !== undefined ? ctor_ret: new_obj;\n};\n\n\n// ** extractFunctionName(f) **\n//\n// extract function name. Does not work for lambas:\n//\n//  ```\n//  > function abc(){}\n//  > u$.extractFunctionName(abc);\n//   \"abc\"\n//  > var xyz = function(){}\n//  > u$.extractFunctionName(xyz)\n//   \"\"\n//  >\n//  ```\nu$.extractFunctionName=function(f) { // because IE does not support Function.prototype.name property\n  var m = f.toString().match(/^\\s*function\\s*([^\\s(]+)/);\n  return m ? m[1] : \"\";\n};\n\n\n// ** getPropertyExtractor(property)**\n//\n// create extractor function that extract property out of object by name:\n//\n//  ```\n//  > var len = u$.getPropertyExtractor(\"length\") ;\n//  > len([0,2,4])\n//   3\n//  >\n//  ```\nu$.getPropertyExtractor=function(property) {\n  return function(o) {\n    return o[property];\n  };\n};\n\n\n// ** combineKeyExtractors(...extractors)**\n//\n// create function that call extractror functions one by one\n// and first `value !== undefined` get returned:\n//\n//  ```\n//  > var len = u$.combineKeyExtractors(['len','size']\n//                     .map(u$.getPropertyExtractor)) ;\n//  > len({size: 3})\n//   3\n//  > len({len: 5})\n//   4\n//  > len({a: 5})\n//   undefined\n//  >\n//  ```\nu$.combineKeyExtractors=function() {\n  var extractors = u$.extractArray(arguments);\n  return function(o) {\n    for ( var i = 0; i < extractors.length; i++) {\n      var key = extractors[i](o);\n      if(key !== undefined){\n        return key;\n      }\n    }\n    return undefined;\n  };\n};\n\n\n//## Collections utils\n\n// ** extractArray(args) **\n//\n// Take arguments object and convert it to array.\n// Useful if you want to consume all arguments of\n// function as elements of one array, yet you want to allow\n// possibility to pass all of them in one argument as\n// array as well.\n//\n// ```\n//  > function x(){\n//  ...     var args = u$.extractArray(arguments);\n//  ...     console.log(args);\n//  ...  }\n//  > x(\"a\",\"b\");\n//   [\"a\", \"b\"]\n//  > var arr=[\"z\",\"y\"];\n//  > x(arr);\n//   [\"z\", \"y\"]\n// ```\nu$.extractArray=function(args) {\n  if ( !args || args.length === 0) {\n    return [];\n  } else if (args.length === 1) {\n    var arg = args[0];\n    if (u$.isArray(arg)) {\n      return arg;\n    }\n  }\n  return Array.prototype.slice.call(args);\n};\n\n\n// **binarySearch(searchFor, array, comparator, mapper)  **\n//\n// search sorted `array` and return index of element that match\n// `searchFor`. If index positive it points on exact matched\n// element. If negative - no match found, and value of `1 - negative_index`\n// will point to where such element should be located in `array`.  `mapper(array_elem)`\n// allow for optional level of indirection, and map value from `array`\n// to object that will be compared with `searchFor`. `comparator(a,b)` is logic\n// that compare objects. It is a order function that roughly does\n// something like: `a < b ? -1 : a > b ? 1 : 0`\n//\n// ```\n//  > var array = [ 1, 2, 4, 6, 8, 10, 25 ];\n//  > u$.binarySearch(4, array, t$.number.compare);\n//   2\n//  > u$.binarySearch(7, array, t$.number.compare);\n//   -5\n// ```\nu$.binarySearch=function(searchFor, array, comparator, mapper) {\n  var mapToValue = mapper || function(x) {\n        return x;\n      };\n  var min = 0;\n  var max = array.length - 1;\n  var mid, r;\n  while (min <= max) {\n    mid = ((min + max) / 2) | 0;\n    r = comparator(searchFor, mapToValue(array[mid]));\n    if (r > 0) {\n      min = mid + 1;\n    } else if (r < 0) {\n      max = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1 - min;\n};\n\n\n//** range(start,end,step) **\n//\n//  replica of python's `range()`. returns array of numbers from\n//  `start`(inclusive) to  `end` (exclusive) spaced  with `step`.\n//  Defaults for `start=0` and `step=1`. Two argument call expects\n//  `range(start,end)`, and one argument is just `range(end)`.\nu$.range=function(start, end, step) {\n  if(u$.isUndef(step)) {\n    step = 1;\n  }\n  if(u$.isUndef(end)) {\n    end = start;\n    start = 0;\n  }\n  var values = [];\n  for (; start < end; start+=step) {\n    values.push(start);\n  }\n  return values;\n};\n\n//**repeat(n,value)**\n//\n// repeats `value` in array `n` times.  If `value` is function\n// result of `value(i)` call will be stored in array instead.\n\nu$.repeat=function(n, value) {\n  var result = [];\n  for ( var i = 0; i < n; i++) {\n    result.push(u$.isFunction(value) ? value(i) : value);\n  }\n  return result;\n};\n\n//**convertListToObject(array,extractor) **\n//\n// converts array to object.  `extractor(v)` retrieve key  from each\n// element of array. If key is defined key-value pair will be stored\n// in object.\nu$.convertListToObject=function(array,extractor) {\n  var obj = {};\n  for ( var i = 0; i < array.length; i++) {\n    var v = array[i];\n    var k = extractor(v);\n    if( k !== undefined ){\n      obj[k] = v;\n    }\n  }\n  return obj;\n};\n\n\n//** convertFunctionsToObject(funcList)**\n//\n// Extract name of functions and use them as keys to reshape `funcList` array\n// to object.\nu$.convertFunctionsToObject=function(funcList) {\n  return u$.convertListToObject(funcList,\n      u$.combineKeyExtractors(\n          u$.getPropertyExtractor(\"name\"),\n          u$.extractFunctionName));\n};\n\n\n//** applyOnAll(obj, action) **\n//\n// apply `action(v,k,obj)` on all elements of `obj`\n// object\nu$.applyOnAll=function(obj, action) {\n  for ( var k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      action(obj[k], k, obj);\n    }\n  }\n};\n\n\n//** append(object,params,excludes?) **\n//\n// append all key-value pairs form `params` element to `object`.\n// if there is key with same name in `params` and in `object`,\n// one from `params` will overwrite one in the object. If key is\n// mentioned in `excludes` it will be omitted.\nu$.append=function(object, params, excludes) {\n  for ( var key in params) {\n    if ( params.hasOwnProperty(key) &&\n        ( !excludes || !excludes.contains(key) ) ) {\n      object[key] = params[key];\n    }\n  }\n  return object;\n};\n\n\n//** size(obj) **\n//\n// count number of own keys in `object`.\nu$.size=function(obj) {\n  var sz = 0;\n  for ( var key in obj) {\n    if (obj.hasOwnProperty(key)){\n      sz++;\n    }\n  }\n  return sz;\n};\n\n\n//** join(collection, delimiter, toValue)**\n//\n// join elements of `collection`\n//   * `collection` - array or object.\n//   * `delimiter` - delimiter value or function. if omitted `','`\n//     is assumed. When value provided same delimiter will be inserted\n//     in between elements of collection. With function\n//     `delimiter(collection, fromBegining, fromEnd)` you can control\n//     delimiters for each position separately including before first\n//     and after last element. Before and after delimiters set to empty\n//     string by default.\n//   * `toValue` - optional, by default identity function. transform\n//     elements before join.\nu$.join=function(collection, delimiter, toValue) {\n  var keys = u$.isObject(collection) ? Object.keys(collection) : collection;\n  if (!toValue) {\n    toValue = function (s) {\n      return s;\n    };\n  }\n  if (u$.isNullish(delimiter) ) {\n    delimiter = ',';\n  }\n  var doDelimit = delimiter;\n  if (!u$.isFunction(delimiter)) {\n    doDelimit = function (collection, fromBegining, fromEnd) {\n      return (fromBegining < 0 || fromEnd < 0) ? '' : delimiter;\n    };\n  }\n  var indexFromBegining = -1; // -1 means delimiter before of first element\n  var indexFromEnd = keys.length-1; //it become -1 for delimiter after of last element\n  var result = '';\n  while (indexFromBegining < keys.length) {\n    if (indexFromBegining >= 0) {\n      result += toValue(keys[indexFromBegining], collection);\n    }\n    result += doDelimit(keys, indexFromBegining, indexFromEnd, collection);\n    indexFromBegining++;\n    indexFromEnd--;\n  }\n  return result;\n};\n\n\n// ## Misc\n\n//** filterChars(s,filter) **\n//\n// starting from beginning filter all characters\n// that meet `filter(char(string),index(int),whole_string(string))->boolean`\n// function requirements.\n//\n// Returns position where criteria no longer met.\nu$.filterChars=function(s,filter){\n  var at = 0 ;\n  while( at < s.length && filter(s.charAt(at),at,s) ) {\n    at++;\n  }\n  return at;\n};\n\n\n//** detectRepeatingChar(s,prefix_ch) **\n//\n// detect repeating char `prefix_ch` in beginning of the line `s`\nu$.detectRepeatingChar=function(s,prefix_ch){\n  return u$.filterChars(s,function (ch){\n    return ch === prefix_ch;\n  });\n};\n\n//** detectPrefix ( s, prefix ) **\n//\n// checks if `s` starts with `prefix`. Essentially this is the\n// same as `String.prototype.startWith(prefix)` but ES6 not quite here yet.\nu$.detectPrefix=function(s,prefix){\n  return prefix.length === u$.filterChars(s,function (ch,at){\n        return ch === prefix.charAt(at);\n      });\n};\n\n\n//** ensureDate ( a ) **\n//\n// ensure Date object\nu$.ensureDate=function(a) {\n  return a instanceof Date ? a : new Date(a);\n};\n\nu$.ensureString=function(a) {\n  return u$.isString(a) ? a : String(a);\n};\n\n\n//**error(params,err)**\n//\n//creates error object or add params to it as it will fly by.\nu$.error=function(params,  err) {\n  err = err || new Error();\n  params = params || {};\n  if ( u$.isNullish(err._message) ) {\n    err._message  = err.message ? err.message :  params.message || '' ;\n    delete params.message;\n  }\n  if ( u$.isObject(err.params) ) {\n    u$.append(err.params, params);\n  }else{\n    err.params = params;\n  }\n  err.toString = function (){\n    var m =  err._message ;\n    return u$.size(this.params)  ? m + \" \" + JSON.stringify(this.params) : m;\n  };\n  return err;\n};\n//** assert(provided, expected, message) **\n//\n// throws error if `provided` and `expected` are not equal.\nu$.assert=function(provided, expected, message) {\n  function check(expected) {\n    return provided === expected;\n  }\n  var equals = u$.isArray(expected) ? expected.some(check) : check(expected) ;\n  if ( !equals ) {\n    throw u$.error({\n      message : message || \"Unexpected value\",\n      expected : expected,\n      provided : provided,\n    });\n  }\n};\n\n//## Parsing dates\n\n//### some private date related stuff\n\n// pad_with(input,template)\n//\n// pad `input` value according to `template`\n\n// ```\n//  > pad_with(5,'00')\n//   '05'\n//  > pad_with(5,'0000')\n//   '0005'\n// ```\nfunction pad_with(input, template) {\n  var r = String(input);\n  if (r.length !== template.length) {\n    r = (template + r).substr(r.length, template.length);\n  }\n  return r;\n}\n\n// pad_with_zeros(input,n)\n//\n// pad `input` with zeros until it reach `n` size\n//\n// ```\n//  > pad_with_zeros(5,2)\n//   '05'\n//  > pad_with_zeros(5,4)\n//   '0005'\n// ```\nfunction pad_with_zeros(input, n) {\n  var r = String(input);\n  while(r.length < n) {\n    r = '0' + r;\n  }\n  return r;\n}\n\n// define supported date patterns\nvar DATE_PATTERNS = {\n  YYYY_MM_DDThh_mm_ss: { delims: ['-','-','T',':',':'] },\n  YYYY_MM_DD_hh_mm_ss: { delims: ['-','-',' ',':',':'] },\n  YYYYMMDD_hhmmss: { delims: ['','','-','',''] },\n  YYYYMMDDhhmmss: { delims: ['','','','',''] },\n  YYYY_MM_DD: { delims: ['-','-'] },\n  YYYYMMDD: { delims: ['',''] },\n};\n\n//prepare text for regexp\nvar DATE_FIELD_SIZES = [4,2,2,2,2,2];\nvar pattern_texts = DATE_FIELD_SIZES.map(function(n){\n  var s='(';\n  while(n--){\n    s+='\\\\d';\n  }\n  return s+')';\n});\n\n// generate regexps in `DATE_PATTERNS`\nfor(var name in DATE_PATTERNS){\n  var o = DATE_PATTERNS[name];\n  var n = o.delims.length+1;\n  var s = '';\n  for (var i = 0; i < n; i++) {\n    if(i>0){\n      s += o.delims[i-1];\n    }\n    s += pattern_texts[i];\n  }\n  o.regexp=new RegExp(s);\n}\n\n// build date out of components\nfunction new_date(in_utc,components){\n  if (in_utc){\n    return new Date(Date.UTC.apply(null,components));\n  }else{\n    return u$.new_Object(Date, components);\n  }\n}\n\n// try all patters to parse string\nfunction parse_date(in_utc, s){\n  for(var pkey in DATE_PATTERNS){\n    var m = DATE_PATTERNS[pkey].regexp.exec(s);\n    if(m){\n      return new_date(in_utc, (m.length === 4) ? [+m[1],m[2]-1,+m[3]] :\n          [+m[1],m[2]-1,+m[3],+m[4],+m[5],+m[6]] );\n    }\n  }\n  return undefined;\n}\n\n//### Public Date stuff\n\n\n//** date_from_string(s)**\n//\n//  parse string into date assumning UTC timezone\nu$.date_from_string=function(s){\n  return parse_date(true,s);\n};\n\n\n//**date_components(d)**\n//\n// split Date object into array of components :\n// [year, month(1-12), day, hours, minutes, seconds]\n// in local time\nu$.date_components=function(d){\n  return [d.getFullYear(),d.getMonth() + 1,d.getDate(),\n    d.getHours(),d.getMinutes(),d.getSeconds()];\n};\n\n\n//**utc_components(d)**\n//\n// split Date object into array of components :\n// [year, month(1-12), day, hours, minutes, seconds]\n// in UTC time\nu$.utc_components=function(d){\n  return [d.getUTCFullYear(),d.getUTCMonth() + 1,d.getUTCDate(),\n    d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds()];\n};\n\n//**SUPPORTED_DATE_FORMATS**\n// array of supprted  date formats names\n\n// ```\n// > SUPPORTED_DATE_FORMATS\n// [\"YYYY_MM_DDThh_mm_ss\", \"YYYY_MM_DD_hh_mm_ss\", \"YYYYMMDD_hhmmss\",\n//  \"YYYYMMDDhhmmss\", \"YYYY_MM_DD\", \"YYYYMMDD\"]\n// ```\nu$.SUPPORTED_DATE_FORMATS = Object.keys(DATE_PATTERNS);\n\n\n//**date_to_string_fn(format,components_fn)**\n//\n// create function that will convert Date object into string.\n//   * `format` - format name. See SUPPORTED_DATE_FORMATS above.\n//   * `components_fn` - (optional) one of 2 functions that to split date\n//     into components `utc_components` (default) and `date_components` .\n\nu$.date_to_string_fn=function(format,components_fn){\n  components_fn = components_fn || u$.utc_components;\n  var delims = DATE_PATTERNS[format].delims ;\n  return function(d){\n    var d_values = components_fn(d);\n    var n = delims.length+1;\n    var s = '';\n    for (var i = 0; i < n; i++) {\n      if(i > 0){\n        s += delims[i-1];\n      }\n      s += pad_with_zeros(d_values[i],DATE_FIELD_SIZES[i]);\n    }\n    return s;\n  };\n};\n//**dateToIsoString(date)**\n//\n// date to ISO-2601 string. deprecated in favor\n// of `Date.prototype.toISOString`. will be removed soon.\n//\n//\nu$.dateToIsoString=function(date) {\n  return date.toISOString();\n  /*return date.getUTCFullYear() +  '-' +\n   pad_with(date.getUTCMonth() + 1, '00') + '-' +\n   pad_with(date.getUTCDate(), '00') + 'T' +\n   pad_with(date.getUTCHours(), '00') + ':' +\n   pad_with(date.getUTCMinutes(), '00') + ':' +\n   pad_with(date.getUTCSeconds(), '00') + '.' +\n   pad_with(date.getUTCMilliseconds(), '000') + 'Z';*/\n};\n//** parseDateUTC(s) **\n//\n// parse date using on of `SUPPORTED_DATE_FORMATS`\n// assuming UTC timezone\n\nu$.parseDateUTC=function(s){\n  return parse_date(true,s);\n};\n//** relativeDateString(date,rel) **\n//\n// produce string representation of UTC time in format\n//   * `+-hh:mm` if diffirence between `date` and `rel`\n//     less then 24 hours\n//   * `YYYY-MM-DD hh:mm` otherwise\n// ```\n// > relativeDateString(new Date(d.getTime()+120000),d)\n//  \"+00:02\"\n// > relativeDateString(new Date(d.getTime()-120000),d)\n//  \"-00:02\"\n// > relativeDateString(new Date(d.getTime()-1200000000),d)\n//  \"2015-10-22 08:34\"\n// ```\nu$.relativeDateString=function(date,rel) {\n  if(!u$.isDate(date)){\n    if(!u$.isNullish(date)){\n      date = u$.parseDateUTC(date);\n    }else{\n      return \"\";\n    }\n  }\n  if(!u$.isDate(rel)){\n    rel = new Date();\n  }\n  if( Math.abs(date.getTime() - rel.getTime()) < 86400000 ){\n    var a = Math.floor( (date.getTime() - rel.getTime())  / 1000);\n    var s = Math.abs(a) + 30;\n    var m = Math.floor( s / 60 );\n    var h = Math.floor( m / 60 );\n    s = s % 60;\n    m = m % 60;\n    return (a < 0 ? '-' : '+') + pad_with(h, '00') + ':' + pad_with(m, '00')  ;\n  }\n  return date.getUTCFullYear() + '-' +\n      pad_with(date.getUTCMonth() + 1, '00') + '-' +\n      pad_with(date.getUTCDate(), '00') + ' ' +\n      pad_with(date.getUTCHours(), '00') + ':' +\n      pad_with(date.getUTCMinutes(), '00') ;\n\n};\n\n// ## Bi-directional map\n\n// ** BiMap(map) **\n//\n// class that allow to maintain forward reference from key to value,\n// as well inverse as from value to key. If values are not unique,\n// it will be mapped to only one of the keys. Changes to `BiMap`\n// will be reflected in underlying `map` object as well. It is better\n// to use strings both as keys and values, because object keys casted\n// to strings, and we use values as keys in inverse mapping too.\n// ```\n// > var o = {}\n// > var bm = u$.BiMap(o)\n// > bm.put(5,3)\n// > bm.key(3)\n//  \"5\"\n// > bm.get(5)\n//  3\n// > bm.values()\n//  [\"3\"]\n// > bm.keys()\n//  [\"5\"]\n// > bm.put(\"x\",\"3\")\n// > bm.keys()\n//  [\"5\", \"x\"]\n// > bm.values()\n//  [\"3\"]\n// > bm.key(3)\n//  \"x\"\n// > bm.del(\"x\")\n// > bm.key(3)\n//  \"5\"\n// ```\nu$.BiMap=function(map) {\n  if( ! (this instanceof u$.BiMap) ){\n    return new u$.BiMap(map);\n  }\n  var forward = map || {};\n  var _inverse = null;\n  function inverse(){\n    if( _inverse === null ){\n      _inverse = {};\n      for ( var key in forward) {\n        if (forward.hasOwnProperty(key)) {\n          _inverse[forward[key]]=key;\n        }\n      }\n    }\n    return _inverse;\n  }\n  //`get(key)` - get value by key\n  this.get =    function(key) { return forward[key]; };\n  //`key(val)` - get key by value\n  this.key =    function(val) { return inverse()[val]; };\n  //`put(key,val)` - store key-value pair\n  this.put =    function(key,val) { forward[key] = val; _inverse = null; };\n  //`del(key)` - delete key-value pair by key\n  this.del =    function(key) { delete forward[key];_inverse = null; };\n  //`keys()` - get all keys\n  this.keys =   function() { return Object.keys(forward); };\n  //`values()` - get all distinct values\n  this.values = function() { return Object.keys(inverse()); };\n};\n\n// ## Stuff should be thrown away but I am reactant for  some reason\n\n// Tokenizer\nu$.Tokenizer=function(s, delimiters) {\n  var i = 0;\n\n  function isValueChar() {\n    return delimiters.indexOf(s.charAt(i)) < 0;\n  }\n\n  function next(condition) {\n    var start = i;\n    while (i < s.length && condition()){\n      i++;\n    }\n    return s.substring(start, i);\n  }\n\n  return {\n    getText : function() {\n      return s;\n    },\n    nextValue : function() {\n      return next(isValueChar);\n    },\n    nextDelimiter : function() {\n      return next(function() {\n        return !isValueChar();\n      });\n    },\n    toString : function() {\n      return s.substring(0, i) + \" <-i-> \" + s.substring(i);\n    },\n    getPosition : function() {\n      return i;\n    },\n    setPosition : function(_i) {\n      i = _i;\n    }\n  };\n};\n\nvar mappingEntities = {\n  \"<\" : \"&lt;\",\n  \">\" : \"&gt;\",\n  \"&\" : \"&amp;\",\n  '\"' : \"&quot;\",\n  \"'\" : \"&#39;\",\n};\n\nfunction escapeEntities(s, delims) {\n  var t = new u$.Tokenizer(s, delims);\n  var r = \"\";\n  for (;;) {\n    var v = t.nextValue();\n    var d = t.nextDelimiter();\n    if (v) {\n      r += v;\n    }\n    if (d) {\n      for ( var i = 0; i < d.length; i++) {\n        r += mappingEntities[d.charAt(i)];\n      }\n    }\n    if (!v && !d) {\n      return r;\n    }\n  }\n}\n\nu$.escapeXmlAttribute=function(s) {\n  return escapeEntities(s, \"<>&'\\\"\");\n};\n\nu$.escapeXmlBody=function(s) {\n  return escapeEntities(s, \"<>&\");\n};\n\n//** splitUrlPath(urlpath) **\n//\n// spit url path on path elements, and variables.\n//\nu$.splitUrlPath=function(urlpath) {\n  var path = urlpath.split(\"/\");\n  var last = path[path.length-1].split('?');\n  var result = {\n    path: path ,\n    variables: {},\n    toString: function(){\n      var vars = '' ;\n      var sep = '?' ;\n      for ( var k in this.variables) {\n        if (this.variables.hasOwnProperty(k)) {\n          vars += sep + k + '=' + encodeURI(this.variables[k]);\n          sep = '&';\n        }\n      }\n      return this.path.join('/') + vars;\n    }\n  };\n  if( last.length === 2 ){\n    path[path.length-1] = last[0];\n    last[1].split(\"&\").forEach(function(part) {\n      var item = part.split(\"=\");\n      if( item[0].length > 0 ){\n        result.variables[item[0]] = decodeURIComponent(item[1]);\n      }\n    });\n  }else if(last.length > 2){\n    throw 'Unexpected number of \"?\" in url :' + urlpath ;\n  }\n  return result;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wdf/utils.js\n ** module id = 2\n ** module chunks = 0\n **/","// ## Private stuff\n//\n// methods and classes that not supposed to be used directly\nvar u$ = require(\"./utils\");\n\n// `Column` has `name`. Also `data` array is there to store all column's value.\n// Optionally if `type` defined when all `data` assumed to be casted to that type (\n// See [type](types.html) ). Also `col_idx` point on this column in column set.\n\nvar Column = function (name,len,type){\n  this.name = name;\n  this.data = [];\n  if( len ){\n    this.data.length = len ;\n  }\n  this.type = type ;\n};\n\n// ColumnSet - store all columns `byIndex` in array and  `byName` in hashtable.\nvar ColumnSet = function(){\n  this.byIndex = [];\n  this.byName = {};\n};\n\n// get column either by name or by index\nColumnSet.prototype.getColumn = function(name_or_idx){\n  return (u$.isNumber(name_or_idx) ? this.byIndex : this.byName )[name_or_idx];\n};\n\n// enforce column by name\nColumnSet.prototype.enforceColumn = function(name,n_rows,type){\n  var c = this.byName[name];\n  if( u$.isNullish(c) ){\n    c = new Column(name ,n_rows, type);\n    c.col_idx = this.byIndex.length;\n    this.byIndex.push(c);\n    this.byName[name] = c;\n  }\n  return c;\n};\n\n// enforce column by `col_idx`, `name` will be set to `'c'+col_idx`\nColumnSet.prototype.enforceColumnAt = function(col_idx,n_rows,type){\n  var c = this.byIndex[col_idx];\n  if( u$.isNullish(c) ){\n    var name = \"c\"+col_idx ;\n    c = new Column(name, n_rows, type);\n    c.col_idx = col_idx;\n    this.byIndex[col_idx] = c;\n    this.byName[name] = c;\n  }\n  return c;\n};\n\n// add bunch of columns, preallocate array for `n_rows`\nColumnSet.prototype.addColumns = function(cols,n_rows){\n  for(var i = 0 ; i < cols.length ; i++){\n    var name = cols[i], type ;\n    if(u$.isObject(cols[i])){\n      name = cols[i].name;\n      type = cols[i].type;\n    }\n    this.enforceColumn(name, n_rows, type);\n  }\n  return this;\n};\n\n// ## <section id='DataFrame'>Dataframe</section>\n//\n// **new Dataframe(rows,columns)**:\n//    - `rows` - array of rows. row could be array or object.\n//    - `columns` - array that contains column names or objects with `{name: \"colname\",type: \"number\"}`.\nvar DataFrame = function (rows, columns){\n  var obj = this;\n  if( obj.constructor !== DataFrame ){\n    return new DataFrame(rows,columns);\n  }\n  rows = rows || [];\n  this.columnSet = new ColumnSet().addColumns( columns||[],rows.length);\n  this.index = u$.range(rows.length);\n  for (var row = 0; row < rows.length; row++) {\n    var row_data = rows[row];\n    if( u$.isObject(row_data) ){\n      var keys = Object.keys(row_data);\n      for (var k = 0; k < keys.length; k++) {\n        this.columnSet.enforceColumn(keys[k]).data[row] = row_data[keys[k]];\n      }\n    }else if( u$.isArray(row_data) ){\n      for (var col_idx = 0; col_idx < row_data.length; col_idx++) {\n        this.columnSet.enforceColumnAt(col_idx).data[row] = row_data[col_idx];\n      }\n    }else{\n      throw { msg: \"row should be object or array and not:\"+row_data };\n    }\n  }\n  return obj;\n};\n\n\n// **parse_csv(str,header)**\n//\n// parse comma separated values (CSV) format  provided in string `str`.\n// `header` is array with column names, if omitted first line of  CSV  in `str` considered header .\n\nDataFrame.parse_csv = function (str, header) {\n  var arr = [];\n  var quote = false;  // true means we're inside a quoted field\n\n  var row ,col ,c ;\n  for (row = col = c = 0; c < str.length; c++) {\n    var cc = str[c], nc = str[c+1];        // current character, next character\n    arr[row] = arr[row] || [];             // create a new row if necessary\n    arr[row][col] = arr[row][col] || '';   // create a new column (start with empty string) if necessary\n    if (cc === '\"' && quote && nc === '\"') { // if two quotes inside quoted field\n      arr[row][col] += cc; ++c;\n      continue; // add quote and skip next char\n    }\n    if (cc === '\"') { // if lone quote\n      quote = !quote; continue; // toggle quoted field\n    }\n    if (cc === ',' && !quote) { // if comma in the wild\n      ++col; continue; // start next cell\n    }\n    if (cc === '\\n' && !quote) { // if new line in the wild\n      ++row; col = 0; continue;  // move to next row\n    }\n    arr[row][col] += cc; // or add char to current cell\n  }\n  header = header || arr.shift();\n  return new DataFrame(arr,header);\n};\n// **getRow(row_num,result)**\n//\n// get data row out of DataFrame.\n//    - `row_num` - row number\n//    - `result` - object or array to be filled in. **@optional**\n//       if not provided empty object is assumed.\n\nDataFrame.prototype.getRow=function(row_num,result){\n  var ph_row = this.index[row_num] ;\n  result = result || {};\n  this.columnSet.byIndex.forEach( u$.isArray(result) ?\n      function (c, col_idx) { result[col_idx] = c.data[ph_row]; } :\n      function (c)          { result[c.name] = c.data[ph_row]; });\n  return result;\n};\n// **get(row,col)**\n//\n// get one value out of DataFrame\n//   - `row_num` - row number\n//   - `col` - column index or column name\n//\nDataFrame.prototype.get=function(row_num,col){\n  var ph_row = this.index[row_num] ;\n  var c = this.columnSet.getColumn(col);\n  return c.data[ph_row];\n};\n// **set(row_num,col,v)**\n//\n// set value in one cell of DataFrame\n//   - `row_num` - row number\n//   - `col` - column index or column name\n//   - `v` -  value to set\nDataFrame.prototype.set=function(row_num,col, v){\n  var ph_row = this.index[row_num] ;\n  var c = this.columnSet.getColumn(col);\n  c.data[ph_row] = v;\n};\n// **getRowCount()**\n//\n// get row count\nDataFrame.prototype.getRowCount=function(){\n  return this.index.length;\n};\n//**newRow()**\n//\n//add new row. Returns new row number.\nDataFrame.prototype.newRow=function(){\n  var new_row_num=this.index.length;\n  this.index[new_row_num] = new_row_num;\n  return new_row_num;\n};\n//**deleteRow(row_num)**\n//\n//delete row by `row_num`.\nDataFrame.prototype.deleteRow=function(row_num){\n  this.index.splice(row_num,1);\n};\n// getColumn(col)\n//\n// get all data out column. returns array of values\n//   - `col` - column index or column name\nDataFrame.prototype.getColumn=function(col){\n  var c = this.columnSet.getColumn(col);\n  if(c){\n    return this.index.map(function(idx){\n      return c.data[idx];\n    });\n  }\n  return undefined;\n};\n// ** apply(logic) **\n//\n// run `logic(df,row_num)` function on all rows of DataFrame\n//\n//\nDataFrame.prototype.apply=function(logic){\n  for (var row_num = 0; row_num < this.index.length; row_num++) {\n    logic(this,row_num);\n  }\n};\n// ** map(logic) **\n//\n// run `logic(df,row_num)` function on all rows of DataFrame.\n// Collect results from each run into array. `undefined` results\n// will not be included in array.\n//\n//\nDataFrame.prototype.map=function(logic){\n  var collector = [], r;\n  for (var row_num = 0; row_num < this.index.length; row_num++) {\n    r = logic(this,row_num);\n    if( r !== undefined ){\n      collector.push(r);\n    }\n  }\n  return collector;\n};\n// **getData()**\n//\n// Get all data in structure:\n// returns {Object}\n//   - columns - columns array\n//     - name - column name\n//     - type - column type, if defined\n//   - rows - array of rows. each row array of values.\n//\n\nDataFrame.prototype.getData =function(){\n  var r = {columns:[],rows:[]};\n  var columns = this.columnSet.byIndex;\n  for(var col=0;col < columns.length; col++){\n    var column = columns[col];\n    var col_def = {name: column.name};\n    if(column.type){\n      col_def.type = column.type.name;\n    }\n    r.columns.push( col_def);\n  }\n  r.rows = this.map(function(df,row_num){\n    return df.getRow(row_num,[]);\n  });\n  return r;\n};\n\n// **getObjects()**\n//\n// returns all rows in  array , each row is object\n// with column names pointing to values\n//\n\nDataFrame.prototype.getObjects =function(){\n  return this.map(function(df,row_num){\n    return df.getRow(row_num);\n  });\n};\n\nmodule.exports = DataFrame;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wdf/DataFrame.js\n ** module id = 3\n ** module chunks = 0\n **/"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACn7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;","sourceRoot":""}